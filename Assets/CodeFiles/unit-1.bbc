using "~/Projects/BBLang/Core/StandardLibrary/Primitives.bbc";
using "~/Projects/BBLang/Core/StandardLibrary/System.bbc";
using "~/Projects/BBLang/Core/StandardLibrary/System.Math.bbc";
using "~/Projects/BBLang/Core/StandardLibrary/System.Vectors.bbc";
using "~/Projects/BBLang/Core/StandardLibrary/System.Console.bbc";
using "~/Projects/BBLang/Core/StandardLibrary/System.Memory.bbc";
using "api.bbc";

*Mapped = new MappedMemory;

const f32 PI = 3.14159265359f;
const f32 TAU = PI * 2f;
const f32 G = 9.82f;
const f32 PROJECTILE_V = 20f;
const f32 PROJECTILE_V2 = PROJECTILE_V * PROJECTILE_V;
const u8 true = (u8)1;
const u8 false = (u8)0;

f32 requestSentAt = 0f;
f32 requestSentToDistance = 0f;
f32 requestSentToDirection = 0f;

void SendResponse(f32 direction)
{
    u8[2] v;
    v[0] = (u8)3;
    v[1] = (u8)4;
    send(&v, 2, direction);

    // Vector2 point;
    // point.x = Sin(direction) * 10f;
    // point.y = Cos(direction) * 10f;
    // ldebug(point, 0x00FFFF);
}

void SendRequest(f32 direction)
{
    u8[2] v;
    v[0] = (u8)1;
    v[1] = (u8)2;
    send(&v, 2, direction);

    Vector2 point;
    point.x = Sin(direction) * 10f;
    point.y = Cos(direction) * 10f;
    ldebug(point, 0x0000FF);
}

void Receive()
{
    u8[2] v;

    f32 receivedDirection;
    u8 receivedStrength;
    i32 receivedLength = receive(&v, 2, &receivedDirection, &receivedStrength);
    if (receivedLength != 2) { return; }

    // {
    //     Vector2 point;
    //     point.x = Sin(receivedDirection) * 10f;
    //     point.y = Cos(receivedDirection) * 10f;
    //     ldebug(point, 0xFF00FF);
    // }

    if (v[0] == (u8)1 &&
        v[1] == (u8)2)
    {
        // PrintLine("Sending response ...");
        SendResponse(receivedDirection);
    }
    else if (v[0] == (u8)3 &&
             v[1] == (u8)4)
    {
        if (requestSentAt as i32)
        {
            f32 diff = Min(
                Abs(receivedDirection - requestSentToDirection),
                TAU - Abs(receivedDirection - requestSentToDirection)
            );

            if (diff < 0.6f)
            {
                Unit unit;
                unit.Expires = time() + 5f;
                Vector2 point;
                point.x = Sin(receivedDirection) * requestSentToDistance;
                point.y = Cos(receivedDirection) * requestSentToDistance;
                ToByte2(&point, &unit.Position);
                ldebug(point, 0x00FF00);
                // RecordUnit(&allies, unit);

                requestSentAt = 0f;
                requestSentToDistance = 0f;
                requestSentToDirection = 0f;

                PrintLine("Object identified");
            }
            else
            {
                PrintLine(diff);
            }
        }
        // else
        // {
        //     PrintLine("Unexpected response");
        // }
    }
}

void RecordUnit(List<Unit>* units, Unit unit)
{
    u8 isNew = true;
    for (int i = 0; isNew && i < units.Length(); i++)
    {
        f32 distanceSqr = DistanceSqr(units.Raw()[i].Position, unit.Position);
        if (distanceSqr < 1000f)
        {
            // PrintLine("Update unit ...");
            units.Raw()[i] = unit;
            isNew = false;
        }
    }
    if (isNew)
    {
        if (units.Length() >= 4)
        {
            // PrintLine("Replace new unit ...");
            units.Raw()[0] = unit;
        }
        else
        {
            // PrintLine("Record new unit ...");
            units.Add(unit);
        }
    }
}

i32 IsEnemy(Vector2 point)
{
    i32 isEnemy = (&allies).Length();
    int i = (&allies).Length();
    while (i)
    {
        i--;
        byte2 allyPosition_ = (&allies).Raw()[i].Position;
        Vector2 allyPosition;
        ToFloat2(&allyPosition_, &allyPosition);
        f32 d = DistanceSqr(point, allyPosition);
        if (d < 10f)
        {
            isEnemy--;
        }
    }
    return isEnemy;
}

void Radar()
{
    f32 radarDistance = radar(0);
    if (radarDistance > 0f &&
        Abs(prevRadarDistance - radarDistance) > .5f)
    {
        if (requestSentAt as i32) return;

        prevRadarDistance = radarDistance;

        // Vector2 point;
        // point.x = Sin(Mapped.RadarDirection);
        // point.y = Cos(Mapped.RadarDirection);
        // point.x *= radarDistance;
        // point.y *= radarDistance;
        // ldebug(point, 0xFFFFFF);

        PrintLine("Identifying object ...");

        SendRequest(Mapped.RadarDirection);
        requestSentAt = time();
        requestSentToDistance = radarDistance;
        requestSentToDirection = Mapped.RadarDirection;
    }
    if (radarDistance == 0f)
    {
        prevRadarDistance = 0f;
    }
    Mapped.RadarDirection = (Mapped.RadarDirection + 0.01f) % TAU;
}

struct Unit
{
    byte2 Position;
    f32 Expires;
}

f32 prevRadarDistance = 0f;
Vector2 targetedPosition = new Vector2;
Vector2 currentTarget = new Vector2;
// List<Unit> allies = new List<Unit>(4);
List<Unit> enemies = new List<Unit>(2);

while (1)
{
    Receive();

    if (requestSentAt as i32)
    {
        if ((time() - requestSentAt) > 5f)
        {
            PrintLine("Object didn't respond");

            Vector2 point;
            point.x = Sin(requestSentToDirection);
            point.y = Cos(requestSentToDirection);
            point.x *= requestSentToDistance;
            point.y *= requestSentToDistance;

            requestSentAt = 0f;
            requestSentToDistance = 0f;
            requestSentToDirection = 0f;

            ldebug(point, 0xFF0000);

            // i32 isEnemy = IsEnemy(point);
            // if (isEnemy)
            // {
            //     ldebug(point, 0xFF0000);
            Unit enemy;
            enemy.Expires = time() + 5f;
            ToByte2(&point, &enemy.Position);
            RecordUnit(&enemies, enemy);
            // }
            // else
            // {
            //     ldebug(point, 0x00FF00);
            // }
        }
    }

    Radar();

    // for (int i = (&allies).Length() - 1; i >= 0; i--)
    // {
    //     if (time() >= (&allies).Raw()[i].Expires)
    //     {
    //         (&allies).Remove(i);
    //     }
    //     else
    //     {
    //         Vector2 p1;
    //         byte2 p2 = (&allies).Raw()[i].Position;
    //         ToFloat2(&p2, &p1);
    //         ldebug(p1, 0x00FF00);
    //     }
    // }

    currentTarget = new Vector2;

    for (int i = (&enemies).Length() - 1; i >= 0; i--)
    {
        if (time() >= (&enemies).Raw()[i].Expires)
        {
            (&enemies).Remove(i);
        }
        else
        {
            Vector2 p1;
            byte2 p2 = (&enemies).Raw()[i].Position;
            ToFloat2(&p2, &p1);
            p1.y -= 0.2f;
            ldebug(p1, 0xFF0000);
            currentTarget = p1;
        }
    }

    if (currentTarget.x != 0f ||
        currentTarget.y != 0f)
    {
        if (targetedPosition.x != currentTarget.x ||
            targetedPosition.y != currentTarget.y)
        {
            targetedPosition = currentTarget;

            ldebug(targetedPosition, 0xFF00FF);

            {
                Vector2 targetDirection = Normalised(new Vector2(currentTarget.x, currentTarget.y - 0.2));
                f32 targetAngle = Atan2(targetDirection.x, targetDirection.y);
                if (targetAngle < 0f) { targetAngle += TAU; }
                if (targetAngle >= TAU) { targetAngle -= TAU; }
                Mapped.TurretTargetRotation = targetAngle;
            }

            f32 targetDistance = Magnitude(currentTarget);
            targetDistance -= Cos(Mapped.TurretCurrentAngle) * 2.5f;
            f32 height = Sin(Mapped.TurretCurrentAngle) * 2.5f;
            f32 discriminant = (
                (PROJECTILE_V2 * PROJECTILE_V2) -
                (G * (G * targetDistance * targetDistance + ((4f + height) * -2f * PROJECTILE_V2)))
            )
            if (discriminant < 0f)
            {

            }
            else if (1)
            {
                Mapped.TurretTargetAngle = Atan(
                    (PROJECTILE_V2 + _Sqrt(discriminant)) /
                    (G * targetDistance)
                ) - (PI * 0.5f);
            }
            else
            {
                Mapped.TurretTargetAngle = Atan(
                    (PROJECTILE_V2 - _Sqrt(discriminant)) /
                    (G * targetDistance)
                ) - (PI * 0.5f);
            }
        }

        if (Abs(Mapped.TurretCurrentRotation - Mapped.TurretTargetRotation) < 0.1f)
        {
            Mapped.InputShoot = (u8)1;
        }
    }
}
