using "move.bbc";
using "api.bbc";

[UnitCommand(1, "Extract")]
struct CommandExtract
{
    [Context("position")] float2 position;
}

[UnitCommand(2, "Move to")]
struct CommandMoveTo
{
    [Context("position")] float2 position;
}

const int MaxCommandDataSize = 8;

void Receive()
{
    u8[MaxPacketLength] v;
    float3 direction;

    while (1)
    {
        i32 receivedLength = wreceive(&v, MaxPacketLength, &direction);
        if (!receivedLength) { break; }

        if (v[0] == (u8)REQUEST_HEADER &&
            receivedLength == sizeof(VerificationRequestPacket))
        {
            VerificationRequestPacket* packet = &v as VerificationRequestPacket*;

            if (distancesqr(packet.position, GPS.position) < DistanceThresholdSq)
            {
                printline(" M");
                VerificationResponsePacket responsePacket = new VerificationResponsePacket;
                responsePacket.header = (u8)RESPONSE_HEADER;
                responsePacket.position = packet.position;
                debug(packet.position, CYAN);
                wsend(&responsePacket as u8[]*, sizeof(VerificationResponsePacket), &direction, 0.1f);
            }
        }
    }
}

float2 currentDestination = new float2;
float2 currentExtract = new float2;

while (1)
{
    Receive();

    byte[MaxCommandDataSize] _command;

    int commandId = dequeue_command(&_command);

    if (commandId == 1)
    {
        CommandExtract* command = &_command as CommandExtract*;
        currentExtract = command.position;
        currentDestination = new float2;
    }
    else if (commandId == 2)
    {
        CommandMoveTo* command = &_command as CommandMoveTo*;
        currentExtract = new float2;
        currentDestination = command.position;
    }

    if (currentDestination.x != 0f &&
        currentDestination.y != 0f)
    {
        move_to(currentDestination.x, currentDestination.y);
    }

    if (currentExtract.x != 0f &&
        currentExtract.y != 0f)
    {
        float d = distancesqr(GPS.position, currentExtract);
        if (d < 2f * 2f)
        {
            stop_moving();
            debug(currentExtract, WHITE);

            CombatTurret.shoot = (u8)1;
        }
        else
        {
            move_to(currentExtract.x, currentExtract.y);
        }
    }
}
