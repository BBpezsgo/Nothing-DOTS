using "lib/api.bbc";
using "lib/protocol.bbc";

[UnitCommand(1, "Attack at")]
struct CommandAttackAt
{
    [Context("position3")] float3 position;
}

const int MaxCommandDataSize = 8;

void Receive()
{
    u8[MaxPacketLength] v;
    float3 direction;

    while (1)
    {
        i32 receivedLength = receive(&v, MaxPacketLength, &direction);
        if (!receivedLength) { break; }

        if (v[0] == (u8)REQUEST_HEADER &&
            receivedLength == sizeof(VerificationRequestPacket))
        {
            VerificationRequestPacket* packet = &v as VerificationRequestPacket*;

            VerificationResponsePacket responsePacket = new VerificationResponsePacket;
            responsePacket.header = (u8)RESPONSE_HEADER;

            if (distancesqr(packet.position, GPS.position) < DistanceThresholdLargeSq)
            {
                responsePacket.position = packet.position;
                debug(packet.position, CYAN);
                send(&responsePacket as u8[]*, sizeof(VerificationResponsePacket), &direction, 0.1f);
            }
            else
            {
                for (int i = 0; i < (&allies).length(); i++)
                {
                    f32 distanceSqr = distancesqr((&allies).raw()[i].position, packet.position);
                    if (distanceSqr < DistanceThresholdSq)
                    {
                        IndirectVerificationResponsePacket indirectResponsePacket = new IndirectVerificationResponsePacket;
                        indirectResponsePacket.header = (u8)INDIRECT_RESPONSE_HEADER;
                        indirectResponsePacket.position = (&allies).raw()[i].position;
                        indirectResponsePacket.expires = (&allies).raw()[i].expires;
                        send(&indirectResponsePacket as u8[]*, sizeof(IndirectVerificationResponsePacket), &direction, 0.1f);
                        return;
                    }
                }
            }
        }
        else if (v[0] == (u8)RESPONSE_HEADER &&
                 receivedLength == sizeof(VerificationResponsePacket))
        {
            VerificationResponsePacket* packet = &v as VerificationResponsePacket*;

            Unit unit;
            unit.position = packet.position;
            unit.recorded = time();
            unit.expires = time() + 10f;
            unit.verification_sent_at = time();
            remove_unit_at(&enemies, unit.position);
            update_unit(&allies, unit);
        }
        else if (v[0] == (u8)ENEMY_HEADER &&
                 receivedLength == sizeof(EnemyNotificationPacket))
        {
            EnemyNotificationPacket* packet = &v as EnemyNotificationPacket*;

            Unit unit;
            unit.position = packet.position;
            unit.recorded = 0f;
            unit.expires = time() + 5f;
            unit.verification_sent_at = time();
            int j = update_unit(&enemies, unit);

            for (int i = 0; i < (&allies).length(); i++)
            {
                if (i != j)
                {
                    direction = (&allies).raw()[i].position;
                    tolocal(&direction);
                    normalise(&direction);

                    printline("NTFY");

                    send(&packet as u8[]*, sizeof(EnemyNotificationPacket), &direction);
                }
            }
        }
        else if (v[0] == (u8)INDIRECT_RESPONSE_HEADER &&
                 receivedLength == sizeof(IndirectVerificationResponsePacket))
        {
            IndirectVerificationResponsePacket* packet = &v as IndirectVerificationResponsePacket*;

            Unit unit;
            unit.position = packet.position;
            unit.recorded = time();
            unit.expires = packet.expires;
            unit.verification_sent_at = time();
            remove_unit_at(&enemies, unit.position);
            update_unit(&allies, unit);
        }
    }
}

List<Unit> enemies = new List<Unit>(4);
List<Unit> allies = new List<Unit>(4);

UIImage _minimap = new UIImage((i16)22, (i16)22);
_minimap.width = 100;
_minimap.height = 100;
_minimap.x = 10;
_minimap.y = 10;
(&_minimap).update();

const float MinimapScale = 1f;

printline("Started ...");

while (1)
{
    Receive();

    (&_minimap).Fill((u8)0);
    (&_minimap).set(new float2(11f, 11f), (u8)0b_111_111_11);

    for (int i = (&enemies).length() - 1; i >= 0; i--)
    {
        Unit* enemy = &(&enemies).raw()[i];
        if (time() >= enemy.expires)
        {
            (&enemies).remove(i);
        }
        else
        {
            try_send_verification_request(enemy);
            float3 p = enemy.position;
            tolocal(&p);
            if (time() >= enemy.recorded + 4f)
            {
                ldebug(p, RED);
                (&_minimap).set((new float2(p.x, p.z) * (0.5f * MinimapScale) + new float2(11f, 11f)), (u8)((int)(0b_111 * max(0f, enemy.expires - time()) / 10f) << 5));
                printline(p.x);
            }
        }
    }

    for (int i = (&allies).length() - 1; i >= 0; i--)
    {
        Unit* ally = &(&allies).raw()[i];
        if (time() >= ally.expires)
        {
            try_send_verification_request(ally);
            (&allies).remove(i);
        }
        else
        {
            float3 p = ally.position;
            debug(p, GREEN);
            tolocal(&p);
            (&_minimap).set((new float2(p.x, p.z) * (0.5f * MinimapScale) + new float2(11f, 11f)), (u8)((int)(0b_111 * max(0f, ally.expires - time()) / 10f) << 2));
        }
    }

    byte[MaxCommandDataSize] _command;

    int commandId = dequeue_command(&_command);

    if (commandId == 1)
    {
        CommandAttackAt* command = &_command as CommandAttackAt*;
        debug(command.position, RED);

        EnemyNotificationPacket notificationPacket;
        notificationPacket.header = ENEMY_HEADER;
        notificationPacket.position = command.position;
        send(&notificationPacket as u8[]*, sizeof(EnemyNotificationPacket));
    }

    (&_minimap).update();
}
