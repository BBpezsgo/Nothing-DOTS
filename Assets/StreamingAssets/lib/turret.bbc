using "api.bbc";

const f32 G = 9.82f;
const f32 PROJECTILE_V = 40f;
const f32 PROJECTILE_V2 = PROJECTILE_V * PROJECTILE_V;
const f32 HEIGHT_OFFSET = 0;

f32 calculate_angle(f32 targetDistance)
{
    float a = (G * targetDistance) / PROJECTILE_V2;
    if (a < -1f || a > 1f)
    {
        return -0.785398f;
    }
    else
    {
        return -0.5f * asin(a);
    }
}

f32 calculate_angle(f32 targetDistance, f32 height)
{
    f32 discriminant = (
        (PROJECTILE_V2 * PROJECTILE_V2) -
        (G * (G * targetDistance * targetDistance + ((HEIGHT_OFFSET + height) * 2f * PROJECTILE_V2)))
    );

    if (discriminant < 0f)
    {
        return -0.785398f;
    }
    else if (1)
    {
        return atan(
            (PROJECTILE_V2 + sqrt(discriminant)) /
            (G * targetDistance)
        ) - (PI * 0.5f);
    }
    else
    {
        return atan(
            (PROJECTILE_V2 - sqrt(discriminant)) /
            (G * targetDistance)
        ) - (PI * 0.5f);
    }
}

u8 calculate_angle(f32 targetDistance, f32 height, f32* angle)
{
    f32 discriminant = (
        (PROJECTILE_V2 * PROJECTILE_V2) -
        (G * (G * targetDistance * targetDistance + (height * 2f * PROJECTILE_V2)))
    );

    if (discriminant < 0f)
    {
        return (u8)0;
    }
    else if (1)
    {
        *angle = atan(
            (PROJECTILE_V2 + sqrt(discriminant)) /
            (G * targetDistance)
        ) - (PI * 0.5f);
        return (u8)1;
    }
    else
    {
        *angle = atan(
            (PROJECTILE_V2 - sqrt(discriminant)) /
            (G * targetDistance)
        ) - (PI * 0.5f);
        return (u8)1;
    }
}

f32 calculate_rotation(float2 target)
{
    float2 targetDirection = normalise(target);
    f32 targetAngle = atan2(targetDirection.y, targetDirection.x);
    if (targetAngle < 0f) { targetAngle += TAU; }
    if (targetAngle >= TAU) { targetAngle -= TAU; }
    return targetAngle;
}

export u8 targetat(float2 target, float2* targetedPosition)
{
    if (target.x == 0f &&
        target.y == 0f)
    {
        return (u8)0;
    }

    if (targetedPosition.x != target.x ||
        targetedPosition.y != target.y)
    {
        *targetedPosition = target;
        target.y -= 0.2f;

        CombatTurret.target_rotation = calculate_rotation(target);

        f32 targetDistance = length(target);
        // targetDistance -= cos(CombatTurret.current_angle) * 2.5f;
        // f32 height = sin(CombatTurret.current_angle) * 2.5f;

        CombatTurret.target_angle = calculate_angle(targetDistance);
    }

    f32 diff1 = abs(CombatTurret.current_rotation - CombatTurret.target_rotation);
    f32 diff2 = abs(CombatTurret.current_angle - CombatTurret.target_angle);

    if ((diff1 < 0.1f || TAU - diff1 < 0.1f) && (diff2 < 0.01f || TAU - diff2 < 0.01f))
    {
        return (u8)1;
    }

    return (u8)0;
}

const float ProjectileV = 40f;
const float ProjectileV2 = ProjectileV * ProjectileV;
const float ProjectileV4 = ProjectileV2 * ProjectileV2;

u8 solve_ballistic_arc(float3 selfWorldPosition, float3 targetPosition, float3* shootDirection)
{
    float3 diff = targetPosition - selfWorldPosition;
    float groundDistance = sqrt(diff.x * diff.x + diff.z * diff.z);

    float root = ProjectileV4 - G * (G * groundDistance * groundDistance + 2.0 * diff.y * ProjectileV2);

    if (root < 0) return (u8)0;

    root = sqrt(root);
    float gx = G * groundDistance;

    float lowAng = atan2(ProjectileV2 - root, gx);
    //float highAng = atan2(ProjectileV2 + root, gx);

    float3 groundDir = new float3(diff.x, 0f, diff.z) / groundDistance;
    *shootDirection = groundDir * cos(lowAng) + new float3(0.0, 1.0, 0.0) * sin(lowAng);

    return (u8)1;
}

export u8 targetat(float3 target, float3* targetedPosition)
{
    if (target.x == 0f &&
        target.z == 0f)
    {
        return (u8)0;
    }

    float3 targetLocal = target;
    tolocal(&targetLocal);

    if (targetedPosition.x != targetLocal.x ||
        targetedPosition.z != targetLocal.z)
    {
        float3 result;
        if (!solve_ballistic_arc(GPS.position + (toglobald(new float3(0.0, 1.0, 0.0)) * 0.5), target, &result))
        {
            return (u8)0;
        }

        tolocald(&result);

        float yaw = atan2(result.x, result.z);
        float pitch = -asin(result.y);

        CombatTurret.target_rotation = yaw;
        CombatTurret.target_angle = pitch;

        *targetedPosition = targetLocal;
    }

    f32 diff1 = abs(CombatTurret.current_rotation - CombatTurret.target_rotation);
    f32 diff2 = abs(CombatTurret.current_angle - CombatTurret.target_angle);

    if ((diff1 < 0.1f || TAU - diff1 < 0.1f) && (diff2 < 0.01f || TAU - diff2 < 0.01f))
    {
        return (u8)1;
    }

    return (u8)0;
}

export u8 targetat_simple(float2 target, float2* targetedPosition)
{
    if (target.x == 0f &&
        target.y == 0f)
    {
        return (u8)0;
    }

    if (targetedPosition.x != target.x ||
        targetedPosition.y != target.y)
    {
        *targetedPosition = target;
        target.y -= 0.2f;

        CombatTurret.target_rotation = calculate_rotation(target);

        CombatTurret.target_angle = 0.00001f; // TODO: fix this
    }

    f32 diff = abs(CombatTurret.current_rotation - CombatTurret.target_rotation);

    if (diff < 0.1f || TAU - diff < 0.1f)
    {
        return (u8)1;
    }

    return (u8)0;
}

export u8 targetat_simple(float3 target, float3* targetedPosition)
{
    if (target.x == 0f &&
        target.z == 0f)
    {
        return (u8)0;
    }

    tolocal(&target);

    if (targetedPosition.x != target.x ||
        targetedPosition.z != target.z)
    {
        *targetedPosition = target;

        float3 targetDirection3 = normalise(target);
        f32 targetAngle = atan2(targetDirection3.x, targetDirection3.z);
        if (targetAngle < 0f) { targetAngle += TAU; }
        if (targetAngle >= TAU) { targetAngle -= TAU; }
        CombatTurret.target_rotation = targetAngle;

        float horizontalDist = sqrt(targetDirection3.x * targetDirection3.x + targetDirection3.z * targetDirection3.z);
        float pitch = atan2(targetDirection3.y, horizontalDist) * -1;

        CombatTurret.target_angle = pitch;
    }

    f32 diff1 = abs(CombatTurret.current_rotation - CombatTurret.target_rotation);

    if ((diff1 < 0.1f || TAU - diff1 < 0.1f))
    {
        return (u8)1;
    }

    return (u8)0;
}

export void shootat(float2 target, float2* targetedPosition)
{
    CombatTurret.shoot = targetat(target, targetedPosition);
}

export void shootat(float3 target, float3* targetedPosition)
{
    CombatTurret.shoot = targetat(target, targetedPosition);
}

export void shootat_simple(float2 target, float2* targetedPosition)
{
    CombatTurret.shoot = targetat_simple(target, targetedPosition);
}

export void shootat_simple(float3 target, float3* targetedPosition)
{
    CombatTurret.shoot = targetat_simple(target, targetedPosition);
}
