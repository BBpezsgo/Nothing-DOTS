using "~/Projects/BBLang/Core/StandardLibrary/System.bbc";
using "mm.bbc";
using "utils.bbc";

export void print(float2 v)
{
    print(v.x);
    print(' ');
    print(v.y);
}

export inline void printline(float2 v)
{
    print(v);
    printline();
}

export void print(float3 v)
{
    print(v.x);
    print(' ');
    print(v.y);
    print(' ');
    print(v.z);
}

export inline void printline(float3 v)
{
    print(v);
    printline();
}

export void sleep(f32 sec)
{
    f32 at = time() + sec;
    while (time() < at) { }
}

export const u8 BLUE = (u8)0b001;
export const u8 GREEN = (u8)0b010;
export const u8 CYAN = (u8)0b011;
export const u8 RED = (u8)0b100;
export const u8 MAGENTA = (u8)0b101;
export const u8 YELLOW = (u8)0b110;
export const u8 WHITE = (u8)0b111;

[External("atan2")] export f32 atan2(f32 y, f32 x);
[External("tan")] export f32 tan(f32 v);
[External("asin")] export f32 asin(f32 v);
[External("acos")] export f32 acos(f32 v);
[External("atan")] export f32 atan(f32 v);

[External("wreceive")] export i32 wreceive(any* buffer, i32 length, float3* direction);
[External("wsend")] export void wsend(any* buffer, i32 length, float3* direction, f32 angle);

[External("receive")] export i32 receive(any* buffer, i32 length);
[External("send")] export void send(any* buffer, i32 length);

export inline void wsend(any* buffer, i32 length, float3 direction, f32 angle)
{
    wsend(buffer, length, &direction, angle);
}

export inline void wsend(any* buffer, i32 length, float3* direction)
{
    wsend(buffer, length, direction, 0.1f);
}

export inline void wsend(any* buffer, i32 length, float3 direction)
{
    wsend(buffer, length, &direction, 0.1f);
}

export inline void wsend(any* buffer, i32 length)
{
    wsend(buffer, length, (float3*)0, 0f);
}

[External("radar")] void _radar();

export float3 radar(float direction)
{
    Radar.direction = direction;
    //ldebug(new float3(cos(Radar.direction), 0f, sin(Radar.direction)) * 10f, CYAN);
    return radar();
}

export float3 radar()
{
    Radar.response.x = 0f;
    Radar.response.y = 0f;
    Radar.response.z = 0f;

    _radar();

    while (Radar.response.x == 0f || Radar.response.y == 0f || Radar.response.z == 0f)
    {

    }

    if (isnan(Radar.response.x) || isnan(Radar.response.y) || isnan(Radar.response.z))
    {
        return new float3;
    }

    return Radar.response;
}

export void toglobal(byte3* point)
{
    float3 p;
    tofloat3(point, &p);
    toglobal(&p);
    tobyte3(&p, point);
}

export void toglobal(byte2* point)
{
    float2 p;
    tofloat2(point, &p);
    toglobal(&p);
    tobyte2(&p, point);
}

[External("toglobal")] export void toglobal(float3* point);
[External("tolocal")] export void tolocal(float3* point);

[External("toglobald")] export void toglobald(float3* direction);
[External("tolocald")] export void tolocald(float3* direction);

export float3 tolocal(float3 point)
{
    tolocal(&point);
    return point;
}

export float3 toglobal(float3 point)
{
    toglobal(&point);
    return point;
}

export float3 tolocald(float3 direction)
{
    tolocald(&direction);
    return direction;
}

export float3 toglobald(float3 direction)
{
    toglobald(&direction);
    return direction;
}

export void toglobal(float2* point)
{
    float3 _p = new float3(point.x, 0f, point.y);
    toglobal(&_p);
    *point = new float2(_p.x, _p.z);
}

export void tolocal(float2* point)
{
    float3 _p = new float3(point.x, 0f, point.y);
    tolocal(&_p);
    *point = new float2(_p.x, _p.z);
}

[External("time")] export f32 time();

[External("debug")] export void debug(float3 position, u8 color);
[External("ldebug")] export void ldebug(float3 localPosition, u8 color);

export inline void debug(float2 position, u8 color)
{
    debug(new float3(position.x, 0f, position.y), color);
}

export inline void ldebug(float2 localPosition, u8 color)
{
    ldebug(new float3(localPosition.x, 0f, localPosition.y), color);
}

[External("debug_label")] export void debug_label(float3 position, temp string text);
[External("ldebug_label")] export void ldebug_label(float3 localPosition, temp string text);

export inline void debug_label(float2 position, temp string text)
{
    debug_label(new float3(position.x, 0f, position.y), temp text);
}

export inline void ldebug_label(float2 localPosition, temp string text)
{
    ldebug_label(new float3(localPosition.x, 0f, localPosition.y), temp text);
}

[External("dequeue_command")] export int dequeue_command(any* data);

[External("gui_create")] void gui_create(any* ptr);
[External("gui_update")] void gui_update(any* ptr);
[External("gui_destroy")] void gui_destroy(int id);

export u8 colorto255(float r, float g, float b)
{
    return (u8)(
        ((u8)(r * 7) << 5) |
        ((u8)(g * 7) << 2) |
        ((u8)(b * 3))
    );
}

export u8 colorto255(int r, int g, int b)
{
    return (u8)(
        ((u8)(r * 7 / 255) << 5) |
        ((u8)(g * 7 / 255) << 2) |
        ((u8)(b * 3 / 255))
    );
}

export struct UILabel
{
    private bool _dirty;
    private int _id;
    private byte _type;
    int x;
    int y;
    int width;
    int height;
    float3 color;
    char[15] text;

    export UILabel()
    {
        this._type = 1;
        this.x = 50;
        this.y = 50;
        this.width = 50;
        this.height = 50;
        this.text = "Hey";
        gui_create(&this);
    }

    export inline void destroy()
    {
        gui_destroy(this._id);
    }

    export inline void update()
    {
        gui_update(&this);
    }
}

export struct UIImage
{
    private bool _dirty;
    private int _id;
    private byte _type;
    int x;
    int y;
    int width;
    int height;
    i16 imgwidth;
    i16 imgheight;
    byte[510] img;

    export UIImage(i16 width, i16 height)
    {
        this._type = 2;
        this.x = 50;
        this.y = 50;
        this.width = 50;
        this.height = 50;
        this.imgwidth = width;
        this.imgheight = height;
        // for (int y = 0; y < height; y++)
        // {
        //     for (int x = 0; x < width; x++)
        //     {
        //         this.img[x + (y * width)] = (u8)(x + (y * width));
        //     }
        // }
        gui_create(this);
    }

    export inline void destroy()
    {
        gui_destroy(this._id);
    }

    export inline void set(int x, int y, int r, int g, int b)
    {
        this.set(x, y, colorto255(r, g, b));
    }

    export inline void fill(int r, int g, int b)
    {
        this.fill(colorto255(r, g, b));
    }

    export void set(int x, int y, u8 color)
    {
        if (x < 0) x = 0;
        else if (x >= this.imgwidth) x = (int)this.imgwidth;
        if (y < 0) y = 0;
        else if (y >= this.imgheight) y = (int)this.imgheight;
        this.img[y * this.imgwidth + x] = color;
    }

    export void fill(u8 color)
    {
        int l = (int)this.imgwidth * (int)this.imgheight;
        for (int i = 0; i < l; i++)
        {
            this.img[i] = color;
        }
    }

    export inline void update()
    {
        gui_update(this);
    }

    // export inline void set(int2 pos, int r, int g, int b)   { this.set(pos.x, pos.y, r, g, b); }
    // export inline void set(int2 pos, u8 color)              { this.set(pos.x, pos.y, color); }

    export inline void set(float2 pos, int r, int g, int b) { this.set((int)pos.x, (int)pos.y, r, g, b); }
    export inline void set(float2 pos, u8 color)            { this.set((int)pos.x, (int)pos.y, color); }
}

[External("pendrive_plug")]
export void _pendrive_plug();

[External("pendrive_unplug")]
export void _pendrive_unplug();

[External("pendrive_read")]
export int _pendrive_read(int source, byte[]* destination, int length);

[External("pendrive_write")]
export int _pendrive_write(byte[]* source, int destination, int length);

export void _facility_enqueue(TechnologyHash* hash)
{
    Facility.hash_location = hash;
    Facility.signal = (u8)1;
    while (Facility.signal == (u8)1)
    {

    }
}

export u8 _facility_dequeue(TechnologyHash* hash)
{
    Facility.hash_location = hash;
    Facility.signal = (u8)2;
    while (Facility.signal == (u8)2)
    {

    }
    return Facility.signal == (u8)3;
}
