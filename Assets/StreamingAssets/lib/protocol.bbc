export const int MaxPacketLength = 16 + 1;
export const u8 REQUEST_HEADER           = 0b_11110000;
export const u8 RESPONSE_HEADER          = 0b_01111000;
export const u8 ENEMY_HEADER             = 0b_00111100;
export const u8 INDIRECT_RESPONSE_HEADER = 0b_00011110;

export const f32 DistanceThreshold = 2f;
export const f32 DistanceThresholdSq = DistanceThreshold * DistanceThreshold;

export const f32 DistanceThresholdLarge = 5f;
export const f32 DistanceThresholdLargeSq = DistanceThresholdLarge * DistanceThresholdLarge;

export struct VerificationRequestPacket
{
    byte Header;
    float3 Position;
}

export struct VerificationResponsePacket
{
    byte Header;
    float3 Position;
}

export struct IndirectVerificationResponsePacket
{
    byte Header;
    float3 Position;
    float Expires;
}

export struct EnemyNotificationPacket
{
    byte Header;
    float3 Position;
}

export struct Unit
{
    float3 Position;
    f32 Recorded;
    f32 Expires;
    f32 VerificationSentAt;
    u8 PositionRecords;
    f32 NotifiedAt;
}

export void TrySendVerificationRequest(Unit* unit)
{
    if (unit.VerificationSentAt + 1f < time())
    {
        SendVerificationRequest(unit);
    }
}

export void SendVerificationRequest(Unit* unit)
{
    float3 point = unit.Position;

    VerificationRequestPacket packet = new VerificationRequestPacket;
    packet.Header = (u8)REQUEST_HEADER;
    packet.Position = point;

    if (1)
    {
        Print("O-VER ");
        Print(point);
        PrintLine();

        ToLocal(&point);
        ldebug(point, BLUE);
        float distance = Sqrt(point.x * point.x + point.y * point.y + point.z * point.z);
        Normalise(&point);
        float angle = 2f * Atan(3f / (2 * distance));

        send(&packet as u8[]*, sizeof(VerificationRequestPacket), &point, angle);
    }
    else
    {
        send(&packet as u8[]*, sizeof(VerificationRequestPacket));
        debug(point, BLUE);
    }

    unit.VerificationSentAt = time();
}

export int UnitIndexAt(List<Unit>* units, float3 position)
{
    for (int i = 0; i < units.Length(); i++)
    {
        if (DistanceSqr(units.Raw()[i].Position, position) < DistanceThresholdSq)
        { return i; }
    }
    return -1;
}

export int UnitIndexAt(List<Unit>* units, float3 position, float* distanceSqr)
{
    for (int i = 0; i < units.Length(); i++)
    {
        *distanceSqr = DistanceSqr(units.Raw()[i].Position, position);
        if ((*distanceSqr) < DistanceThresholdSq)
        { return i; }
    }
    return -1;
}

export void UpdateUnit(List<Unit>* units, Unit unit)
{
    float distanceSqr = 0f;
    int existing = UnitIndexAt(units, unit.Position, &distanceSqr);
    if (existing == -1)
    {
        if (units.Length() >= 4)
        {
            PrintLine("Too many units");
        }
        else
        {
            units.Add(unit);
        }
    }
    elseif (distanceSqr < 2f * 2f)
    {
        Unit* existingUnit = &units.Raw()[existing];
        if (existingUnit.PositionRecords >= 255)
        {
            unit.PositionRecords = 1;
            units[existing] = unit;
        }
        else
        {
            unit.PositionRecords = existingUnit.PositionRecords + 1;
            float b = (float)(int)unit.PositionRecords;
            float a = (float)(int)existingUnit.PositionRecords / b;
            unit.Position.x = (existingUnit.Position.x * a) + (unit.Position.x / b);
            unit.Position.y = (existingUnit.Position.y * a) + (unit.Position.y / b);
            unit.Position.z = (existingUnit.Position.z * a) + (unit.Position.z / b);
            units[existing] = unit;
            debug(unit.Position, MAGENTA);
        }
    }
    else
    {
        units[existing] = unit;
    }
}

export int SetUnit(List<Unit>* units, Unit unit)
{
    int existing = UnitIndexAt(units, unit.Position);
    if (existing == -1)
    {
        if (units.Length() >= 4)
        {
            PrintLine("Too many units");
            units.Raw()[0] = unit;
            existing = 0;
        }
        else
        {
            existing = units.Length();
            units.Add(unit);
        }
    }
    else
    {
        units[existing] = unit;
    }
    return existing;
}

export void RemoveUnitAt(List<Unit>* units, float3 unit)
{
    u8 isNotDone = true;
    for (int i = 0; isNotDone && i < units.Length(); i++)
    {
        f32 distanceSqr = DistanceSqr(units.Raw()[i].Position, unit);
        if (distanceSqr < DistanceThresholdSq)
        {
            isNotDone = false;
            units.Remove(i);
        }
    }
}
