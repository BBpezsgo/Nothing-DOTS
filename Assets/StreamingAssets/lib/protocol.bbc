export const int MaxPacketLength = 16 + 1;
export const u8 REQUEST_HEADER           = 0b_11110000;
export const u8 RESPONSE_HEADER          = 0b_01111000;
export const u8 ENEMY_HEADER             = 0b_00111100;
export const u8 INDIRECT_RESPONSE_HEADER = 0b_00011110;
export const u8 RADAR_POINT              = 0b_00001111;
export const u8 PCAD                     = 0b_10000111;

export const f32 DistanceThreshold = 2f;
export const f32 DistanceThresholdSq = DistanceThreshold * DistanceThreshold;

export const f32 DistanceThresholdLarge = 5f;
export const f32 DistanceThresholdLargeSq = DistanceThresholdLarge * DistanceThresholdLarge;

export const bool Debug = false;
export const bool Logs = false;

const int MaxUnits = 16;

export struct VerificationRequestPacket
{
    byte header;
    float3 position;
}

export struct VerificationResponsePacket
{
    byte header;
    float3 position;
}

export struct IndirectVerificationResponsePacket
{
    byte header;
    float3 position;
    float expires;
}

export struct EnemyNotificationPacket
{
    byte header;
    float3 position;
}

export struct RadarPointPacket
{
    byte header;
    float3 position;
}

export struct PcAdPacket
{
    byte header;
    float3 position;
}

export struct Unit
{
    float3 position;
    f32 recorded;
    f32 expires;
    f32 verification_sent_at;
    u8 position_records;
    f32 notified_at;
}

export void try_send_verification_request(Unit* unit)
{
    if (unit.verification_sent_at + 1f < time())
    {
        send_verification_request(unit);
    }
}

export void send_verification_request(Unit* unit)
{
    float3 point = unit.position;

    VerificationRequestPacket packet = new VerificationRequestPacket;
    packet.header = (u8)REQUEST_HEADER;
    packet.position = point;

    if (1)
    {
        if (Logs)
        {
            print("O-VER ");
            print(point);
            printline();
        }

        tolocal(&point);
        if (Debug) ldebug(point, BLUE);
        float distance = sqrt(point.x * point.x + point.y * point.y + point.z * point.z);
        normalise(&point);
        float angle = 2f * atan(3f / (2 * distance));

        send(&packet as u8[]*, sizeof(VerificationRequestPacket), &point, angle);
    }
    else
    {
        send(&packet as u8[]*, sizeof(VerificationRequestPacket));
        if (Debug) debug(point, BLUE);
    }

    unit.verification_sent_at = time();
}

export int unit_index_at(List<Unit>* units, float3 position)
{
    for (int i = 0; i < units.length(); i++)
    {
        if (distancesqr(units.raw()[i].position, position) < DistanceThresholdSq)
        { return i; }
    }
    return -1;
}

export int unit_index_at(List<Unit>* units, float3 position, float* distanceSqr)
{
    for (int i = 0; i < units.length(); i++)
    {
        *distanceSqr = distancesqr(units.raw()[i].position, position);
        if ((*distanceSqr) < DistanceThresholdSq)
        { return i; }
    }
    return -1;
}

export int update_unit(List<Unit>* units, Unit unit)
{
    float distanceSqr = 0f;
    int existing = unit_index_at(units, unit.position, &distanceSqr);
    if (existing == -1)
    {
        if (units.length() >= MaxUnits)
        {
            printline("Too many units");
        }
        else
        {
            existing = units.length();
            units.add(unit);
        }
    }
    elseif (distanceSqr < 2f * 2f)
    {
        Unit* existingUnit = &units.raw()[existing];
        if (existingUnit.position_records >= 255)
        {
            existingUnit.position_records = 0;
        }

        existingUnit.position_records++;
        float n = (float)(int)existingUnit.position_records;
        existingUnit.position.x = ((existingUnit.position.x * (n - 1)) / n) + (unit.position.x / n);
        existingUnit.position.y = ((existingUnit.position.y * (n - 1)) / n) + (unit.position.y / n);
        existingUnit.position.z = ((existingUnit.position.z * (n - 1)) / n) + (unit.position.z / n);
        existingUnit.expires = unit.expires;
        debug(unit.position, MAGENTA);
    }
    else
    {
        units[existing] = unit;
    }
    return existing;
}

export int set_unit(List<Unit>* units, Unit unit)
{
    int existing = unit_index_at(units, unit.position);
    if (existing == -1)
    {
        if (units.length() >= MaxUnits)
        {
            printline("Too many units");
            units.raw()[0] = unit;
            existing = 0;
        }
        else
        {
            existing = units.length();
            units.add(unit);
        }
    }
    else
    {
        units[existing] = unit;
    }
    return existing;
}

export void remove_unit_at(List<Unit>* units, float3 unit)
{
    u8 isNotDone = true;
    for (int i = 0; isNotDone && i < units.length(); i++)
    {
        f32 distanceSqr = distancesqr(units.raw()[i].position, unit);
        if (distanceSqr < DistanceThresholdSq)
        {
            isNotDone = false;
            units.remove(i);
        }
    }
}
