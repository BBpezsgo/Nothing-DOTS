using "turret.bbc";
using "api.bbc";

const f32 DISTANCE_THRESHOLD = 50f;

f32 requestSentAt = 0f;
f32 requestSentToDistance = 0f;
f32 requestSentToDirection = 0f;

void SendResponse(f32 direction)
{
    u8[2] v;
    v[0] = (u8)3;
    v[1] = (u8)4;
    send(&v, 2, direction, 0.3f);

    // float2 point;
    // point.x = sin(direction) * 10f;
    // point.y = cos(direction) * 10f;
    // ldebug(point, CYAN);
}

void SendRequest(f32 direction)
{
    u8[2] v;
    v[0] = (u8)1;
    v[1] = (u8)2;
    send(&v, 2, direction, 0.7f);

    float2 point;
    point.x = sin(direction) * 10f;
    point.y = cos(direction) * 10f;
    ldebug(point, BLUE);
}

void Receive()
{
    u8[2] v;
    f32 receivedDirection;

    while (1)
    {
        i32 receivedLength = receive(&v, 2, &receivedDirection);
        if (receivedLength != 2) { break; }

        // {
        //     float2 point;
        //     point.x = sin(receivedDirection) * 10f;
        //     point.y = cos(receivedDirection) * 10f;
        //     ldebug(point, YELLOW);
        // }

        if (v[0] == (u8)1 &&
            v[1] == (u8)2)
        {
            // printline("Sending response ...");
            SendResponse(receivedDirection);
        }
        else if (v[0] == (u8)3 &&
                 v[1] == (u8)4)
        {
            if (requestSentAt as i32)
            {
                f32 diff = min(
                    abs(receivedDirection - requestSentToDirection),
                    TAU - abs(receivedDirection - requestSentToDirection)
                );

                if (diff < 0.6f)
                {
                    Unit unit;
                    unit.expires = time() + 5f;
                    float2 point;
                    point.x = sin(receivedDirection) * requestSentToDistance;
                    point.y = cos(receivedDirection) * requestSentToDistance;
                    tobyte2(&point, &unit.position);
                    ldebug(point, GREEN);

                    requestSentAt = 0f;
                    requestSentToDistance = 0f;
                    requestSentToDirection = 0f;

                    // printline("Object identified");
                }
                else
                {
                    float2 point;
                    point.x = sin(receivedDirection) * 10f;
                    point.y = cos(receivedDirection) * 10f;
                    ldebug(point, YELLOW);
                    // printline(diff);
                }
            }
        }
    }
}

void RecordUnit(List<Unit>* units, Unit unit)
{
    u8 isNew = true;
    for (int i = 0; isNew && i < units.length(); i++)
    {
        f32 distanceSqr = distancesqr(units.raw()[i].position, unit.position);
        if (distanceSqr < DISTANCE_THRESHOLD)
        {
            units.raw()[i] = unit;
            isNew = false;
        }
    }
    if (isNew)
    {
        if (units.length() >= 4)
        {
            units.raw()[0] = unit;
        }
        else
        {
            units.add(unit);
        }
    }
}

i32 IsEnemy(float2 point)
{
    i32 isEnemy = (&allies).length();
    int i = (&allies).length();
    while (i)
    {
        i--;
        byte2 allyPosition_ = (&allies).raw()[i].position;
        float2 allyPosition;
        tofloat2(&allyPosition_, &allyPosition);
        f32 d = distancesqr(point, allyPosition);
        if (d < DISTANCE_THRESHOLD)
        {
            isEnemy--;
        }
    }
    return isEnemy;
}

void PerformRadar()
{
    f32 radarDistance = radar();
    if (radarDistance > 0f &&
        abs(prevRadarDistance - radarDistance) > 1f)
    {
        if (requestSentAt as i32) return;

        prevRadarDistance = radarDistance;

        // float2 point;
        // point.x = sin(Radar.direction);
        // point.y = cos(Radar.direction);
        // point.x *= radarDistance;
        // point.y *= radarDistance;
        // ldebug(point, WHITE);

        // printline("Identifying object ...");

        SendRequest(Radar.direction);
        requestSentAt = time();
        requestSentToDistance = radarDistance;
        requestSentToDirection = Radar.direction;
    }
    if (radarDistance == 0f)
    {
        prevRadarDistance = 0f;
    }
    Radar.direction = (Radar.direction + 0.05f) % TAU;
}

struct Unit
{
    byte2 position;
    f32 expires;
}

f32 prevRadarDistance = 0f;
float2 targetedPosition = new float2;
float2 currentTarget = new float2;
List<Unit> enemies = new List<Unit>(2);

while (1)
{
    Receive();

    if (requestSentAt as i32)
    {
        if ((time() - requestSentAt) > 5f)
        {
            // printline("Object didn't respond");

            float2 point;
            point.x = sin(requestSentToDirection);
            point.y = cos(requestSentToDirection);
            point.x *= requestSentToDistance;
            point.y *= requestSentToDistance;

            requestSentAt = 0f;
            requestSentToDistance = 0f;
            requestSentToDirection = 0f;

            ldebug(point, RED);

            Unit enemy;
            enemy.expires = time() + 5f;
            tobyte2(&point, &enemy.position);
            RecordUnit(&enemies, enemy);
        }
    }

    PerformRadar();

    currentTarget = new float2;

    for (int i = (&enemies).length() - 1; i >= 0; i--)
    {
        if (time() >= (&enemies).raw()[i].expires)
        {
            (&enemies).remove(i);
        }
        else
        {
            float2 p1;
            byte2 p2 = (&enemies).raw()[i].position;
            tofloat2(&p2, &p1);
            ldebug(p1, RED);
            currentTarget = p1;
        }
    }

    shootat(currentTarget, &targetedPosition);
}
