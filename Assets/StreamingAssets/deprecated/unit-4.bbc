using "turret.bbc";
using "move.bbc";
using "api.bbc";
using "protocol.bbc";

[UnitCommand(1, "Attack at")]
struct CommandAttackAt
{
    [Context("position")] float2 position;
}

[UnitCommand(2, "Move to")]
struct CommandMoveTo
{
    [Context("position")] float2 position;
}

const int MaxCommandDataSize = 8;

void Receive()
{
    u8[MaxPacketLength] v;
    f32 direction;

    while (1)
    {
        i32 receivedLength = receive(&v, MaxPacketLength, &direction);
        if (!receivedLength) { break; }

        if (v[0] == (u8)REQUEST_HEADER &&
            receivedLength == sizeof(VerificationRequestPacket))
        {
            VerificationRequestPacket* packet = &v as VerificationRequestPacket*;

            VerificationResponsePacket responsePacket = new VerificationResponsePacket;
            responsePacket.header = (u8)RESPONSE_HEADER;

            if (distancesqr(packet.position, GPS.position) < DistanceThresholdSq)
            {
                responsePacket.position = GPS.position;
                debug(packet.position, CYAN);
                send(&responsePacket as u8[]*, sizeof(VerificationResponsePacket), direction, 0.1f);
            }
            else
            {
                for (int i = 0; i < (&allies).length(); i++)
                {
                    f32 distanceSqr = distancesqr((&allies).raw()[i].position, packet.position);
                    if (distanceSqr < DistanceThresholdSq)
                    {
                        IndirectVerificationResponsePacket indirectResponsePacket = new IndirectVerificationResponsePacket;
                        indirectResponsePacket.header = (u8)INDIRECT_RESPONSE_HEADER;
                        indirectResponsePacket.position = (&allies).raw()[i].position;
                        indirectResponsePacket.expires = (&allies).raw()[i].expires;
                        send(&indirectResponsePacket as u8[]*, sizeof(IndirectVerificationResponsePacket), direction, 0.1f);
                        return;
                    }
                }
            }
        }
        else if (v[0] == (u8)RESPONSE_HEADER &&
                 receivedLength == sizeof(VerificationResponsePacket))
        {
            VerificationResponsePacket* packet = &v as VerificationResponsePacket*;

            Unit unit;
            unit.position = packet.position;
            unit.recorded = time();
            unit.expires = time() + 10f;
            unit.verification_sent_at = time();
            unit.position_records = 1;
            remove_unit_at(&enemies, unit.position);
            update_unit(&allies, unit);
        }
        else if (v[0] == (u8)ENEMY_HEADER &&
                 receivedLength == sizeof(EnemyNotificationPacket))
        {
            EnemyNotificationPacket* packet = &v as EnemyNotificationPacket*;

            Unit unit;
            unit.position = packet.position;
            unit.recorded = 0f;
            unit.expires = time() + 5f;
            unit.verification_sent_at = time();
            unit.position_records = 1;
            update_unit(&enemies, unit);
        }
        else if (v[0] == (u8)INDIRECT_RESPONSE_HEADER &&
                 receivedLength == sizeof(IndirectVerificationResponsePacket))
        {
            IndirectVerificationResponsePacket* packet = &v as IndirectVerificationResponsePacket*;

            Unit unit;
            unit.position = packet.position;
            unit.recorded = time();
            unit.expires = packet.expires;
            unit.verification_sent_at = time();
            unit.position_records = 1;
            remove_unit_at(&enemies, unit.position);
            update_unit(&allies, unit);
        }
    }
}

int unit_index_at(List<Unit>* units, float2 position)
{
    for (int i = 0; i < units.length(); i++)
    {
        if (distancesqr(units.raw()[i].position, position) < DistanceThresholdSq)
        { return i; }
    }
    return -1;
}

int unit_index_at(List<Unit>* units, float2 position, float* distanceSqr)
{
    for (int i = 0; i < units.length(); i++)
    {
        *distanceSqr = distancesqr(units.raw()[i].position, position);
        if ((*distanceSqr) < DistanceThresholdSq)
        { return i; }
    }
    return -1;
}

void update_unit(List<Unit>* units, Unit unit)
{
    float distanceSqr = 0f;
    int existing = unit_index_at(units, unit.position, &distanceSqr);
    if (existing == -1)
    {
        if (units.length() >= 4)
        {
            printline("Too many units");
            units.raw()[0] = unit;
        }
        else
        {
            units.add(unit);
        }
    }
    elseif (distanceSqr < 2f)
    {
        if (units.raw()[existing].position_records > 20)
        {
            unit.position.x = unit.position.x;
            unit.position.y = unit.position.y;
            unit.position_records = 1;
            units[existing] = unit;
        }
        else
        {
            unit.position.x = (units.raw()[existing].position.x * unit.position_records + unit.position.x) / (float)(unit.position_records + 1);
            unit.position.y = (units.raw()[existing].position.y * unit.position_records + unit.position.y) / (float)(unit.position_records + 1);
            unit.position_records++;
            units[existing] = unit;
        }
    }
    else
    {
        unit.position.x = unit.position.x;
        unit.position.y = unit.position.y;
        units[existing] = unit;
    }
}

void remove_unit_at(List<Unit>* units, float2 unit)
{
    u8 isNotDone = true;
    for (int i = 0; isNotDone && i < units.length(); i++)
    {
        f32 distanceSqr = distancesqr(units.raw()[i].position, unit);
        if (distanceSqr < DistanceThresholdSq)
        {
            isNotDone = false;
            units.remove(i);
        }
    }
}

void PerformRadar()
{
    f32 radarDistance = radar();
    if (radarDistance > 0f)
    {
        prevRadarDistance = radarDistance;

        float2 point;
        point.x = cos(Radar.direction);
        point.y = sin(Radar.direction);
        point.x *= radarDistance;
        point.y *= radarDistance;
        toglobal(&point);

        Unit enemy;
        enemy.recorded = time();
        enemy.expires = time() + 12f;
        enemy.position = point;
        enemy.position_records = 1;
        send_verification_request(&enemy);
        update_unit(&enemies, enemy);
    }
    if (radarDistance == 0f)
    {
        prevRadarDistance = 0f;
    }
    Radar.direction = (Radar.direction + 0.05f) % TAU;
}

void try_send_verification_request(Unit* unit)
{
    if (unit.verification_sent_at + 1f < time())
    {
        send_verification_request(unit);
    }
}

void send_verification_request(Unit* unit)
{
    float2 point = unit.position;

    VerificationRequestPacket packet = new VerificationRequestPacket;
    packet.header = (u8)REQUEST_HEADER;
    packet.position = point;

    // tolocal(&point);
    // float distance = sqrt(point.x * point.x + point.y * point.y);
    // normalise(&point);
    // float angle = atan2(point.y, point.x);

    // send(&v, sizeof(VerificationRequestPacket), Radar.direction, asin(1.2f / radarDistance));
    send(&packet as u8[]*, sizeof(VerificationRequestPacket), 0f, 0f);
    debug(point, BLUE);

    unit.verification_sent_at = time();
}

struct Unit
{
    float2 position;
    f32 recorded;
    f32 expires;
    f32 verification_sent_at;
    u8 position_records;
}

f32 prevRadarDistance = 0f;
float2 targetedPosition = new float2;
float2 currentTarget = new float2;
List<Unit> enemies = new List<Unit>(4);
List<Unit> allies = new List<Unit>(4);
float2 currentDestination = new float2;
u8 shouldShoot = false;
f32 turretLastUseTime = 0f;

printline("Started ...");

while (1)
{
    Receive();

    PerformRadar();

    currentTarget = new float2;
    shouldShoot = false;

    for (int i = (&enemies).length() - 1; i >= 0; i--)
    {
        if (time() >= (&enemies).raw()[i].expires)
        {
            (&enemies).remove(i);
        }
        else
        {
            try_send_verification_request(&(&enemies).raw()[i]);
            float2 p = (&enemies).raw()[i].position;
            tolocal(&p);
            if (time() >= (&enemies).raw()[i].recorded + 4f)
            {
                ldebug(p, RED);
                currentTarget = p;
                shouldShoot = true;
            }
            else if (time() >= (&enemies).raw()[i].recorded + 1f)
            {
                ldebug(p, YELLOW);
                currentTarget = p;
            }
            else
            {
                ldebug(p, YELLOW);
            }
        }
    }

    for (int i = (&allies).length() - 1; i >= 0; i--)
    {
        if (time() >= (&allies).raw()[i].expires)
        {
            try_send_verification_request(&(&allies).raw()[i]);
            (&allies).remove(i);
        }
        else
        {
            float2 p = (&allies).raw()[i].position;
            debug(p, GREEN);
        }
    }

    byte[MaxCommandDataSize] _command;

    int commandId = dequeue_command(&_command);

    if (commandId == 1)
    {
        CommandAttackAt* command = &_command as CommandAttackAt*;
        currentTarget = command.position;
        currentDestination = new float2;
        tolocal(&currentTarget);
    }
    else if (commandId == 2)
    {
        CommandMoveTo* command = &_command as CommandMoveTo*;
        currentTarget = new float2;
        currentDestination = command.position;
    }

    if (currentTarget.x != 0f &&
        currentTarget.y != 0f)
    {
        turretLastUseTime = time();
        if (shouldShoot)
        {
            shootat(currentTarget, &targetedPosition);
        }
        else
        {
            targetat(currentTarget, &targetedPosition);
        }
    }
    else if (time() - turretLastUseTime > 5f)
    {
        CombatTurret.target_rotation = 0f;
        CombatTurret.target_angle = 0f;
    }

    if (currentDestination.x != 0f &&
        currentDestination.y != 0f)
    {
        move_to(currentDestination.x, currentDestination.y);
    }
}
