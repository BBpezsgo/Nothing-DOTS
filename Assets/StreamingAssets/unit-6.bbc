using "lib/turret.bbc";
using "lib/move.bbc";
using "lib/api.bbc";
using "lib/protocol.bbc";

[UnitCommand(1, "Attack at")]
struct CommandAttackAt
{
    [Context("position3")] float3 position;
}

[UnitCommand(2, "Move to")]
struct CommandMoveTo
{
    [Context("position2")] float2 position;
}

[UnitCommand(3, "Stop")]
struct CommandStop
{
    
}

const int MaxCommandDataSize = 8;

void Receive()
{
    u8[MaxPacketLength] v;
    float3 direction;

    while (1)
    {
        i32 receivedLength = wreceive(&v, MaxPacketLength, &direction);
        if (!receivedLength) { break; }

        if (v[0] == (u8)REQUEST_HEADER &&
            receivedLength == sizeof(VerificationRequestPacket))
        {
            VerificationRequestPacket* packet = &v as VerificationRequestPacket*;

            if (Logs)
            {
                print("I-REQ ");
                print(packet.position);
                printline();
            }

            if (distancesqr(packet.position, GPS.position) < DistanceThresholdSq)
            {
                if (Logs) printline(" M");
                VerificationResponsePacket responsePacket = new VerificationResponsePacket;
                responsePacket.header = (u8)RESPONSE_HEADER;
                responsePacket.position = GPS.position;
                if (Debug) debug(packet.position, CYAN);
                wsend(&responsePacket as u8[]*, sizeof(VerificationResponsePacket), &direction);
            }
            else
            {
                for (int i = 0; i < (&allies).length(); i++)
                {
                    f32 distanceSqr = distancesqr((&allies).raw()[i].position, packet.position);
                    if (distanceSqr < DistanceThresholdSq)
                    {
                        if (Logs) printline(" K");
                        IndirectVerificationResponsePacket indirectResponsePacket = new IndirectVerificationResponsePacket;
                        indirectResponsePacket.header = (u8)INDIRECT_RESPONSE_HEADER;
                        indirectResponsePacket.position = (&allies).raw()[i].position;
                        indirectResponsePacket.expires = (&allies).raw()[i].expires;
                        wsend(&indirectResponsePacket as u8[]*, sizeof(IndirectVerificationResponsePacket), &direction);
                        return;
                    }
                }
            }
        }
        else if (v[0] == (u8)RESPONSE_HEADER &&
                 receivedLength == sizeof(VerificationResponsePacket))
        {
            VerificationResponsePacket* packet = &v as VerificationResponsePacket*;

            if (Logs)
            {
                print("I-RES ");
                print(packet.position);
                printline();
            }

            Unit unit;
            unit.position = packet.position;
            unit.recorded = time();
            unit.expires = time() + 10f;
            unit.verification_sent_at = time();
            unit.position_records = 1;
            remove_unit_at(&enemies, unit.position);
            update_unit(&allies, unit);
        }
        else if (v[0] == (u8)ENEMY_HEADER &&
                 receivedLength == sizeof(EnemyNotificationPacket))
        {
            EnemyNotificationPacket* packet = &v as EnemyNotificationPacket*;

            Unit unit;
            unit.position = packet.position;
            unit.recorded = 0f;
            unit.expires = time() + 5f;
            unit.verification_sent_at = time();
            unit.position_records = 1;

            if (Logs)
            {
                print("I-E ");
                printline(unit.position);
            }
            update_unit(&enemies, unit);
        }
        else if (v[0] == (u8)INDIRECT_RESPONSE_HEADER &&
                 receivedLength == sizeof(IndirectVerificationResponsePacket))
        {
            IndirectVerificationResponsePacket* packet = &v as IndirectVerificationResponsePacket*;

            if (Logs)
            {
                print("I-RES ");
                print(packet.position);
                printline();
            }

            Unit unit;
            unit.position = packet.position;
            unit.recorded = time();
            unit.expires = packet.expires;
            unit.verification_sent_at = time();
            unit.position_records = 1;
            remove_unit_at(&enemies, unit.position);
            update_unit(&allies, unit);
        }
        else
        {
            print("INVSEQ ");
            print(v[0]);
            printline();
        }
    }
}

float3 targetedPosition = new float3;
float3 currentTarget = new float3;
float3 currentUserTarget = new float3;
List<Unit> enemies = new List<Unit>(4);
List<Unit> allies = new List<Unit>(4);
float2 currentDestination = new float2;
u8 shouldShoot = false;
f32 turretLastUseTime = 0f;

printline("Started ...");

while (1)
{
    Receive();

    currentTarget = new float3;
    shouldShoot = false;

    for (int i = (&enemies).length() - 1; i >= 0; i--)
    {
        if (time() >= (&enemies).raw()[i].expires)
        {
            if (Logs) printline("#E-OLD");
            (&enemies).swapback(i);
        }
        else
        {
            float3 p = (&enemies).raw()[i].position;
            tolocal(&p);

            float3 norm = p;
            norm.y = 0f;
            normalise(&norm);
            float radarDirection = atan2(norm.z, norm.x);
            float3 radarPoint = radar(radarDirection);
            bool destroyed = empty(radarPoint) || distancesqr(p, radarPoint) > DistanceThresholdSq;
            const float increment = 0.04f;
            float currentIncrement = increment;
            while (destroyed && currentIncrement < 0.2f)
            {
                float3 radarPoint = radar(radarDirection + currentIncrement);
                destroyed = empty(radarPoint) || distancesqr(p, radarPoint) > DistanceThresholdSq;
                if (destroyed)
                {
                    float3 radarPoint = radar(radarDirection - currentIncrement);
                    destroyed = empty(radarPoint) || distancesqr(p, radarPoint) > DistanceThresholdSq;
                }
                currentIncrement += increment;
            }

            if (destroyed)
            {
                if (Logs)
                {
                    printline("#E-DESTROYED");
                    printline(radarPoint);
                    printline(Radar.direction);
                    //printline(norm);
                }
                (&enemies).swapback(i);
            }
            elseif (time() >= (&enemies).raw()[i].recorded + 1f)
            {
                toglobal(&p);
                debug(p, RED);
                currentTarget = p;
                shouldShoot = true;
            }
            else
            {
                toglobal(&p);
                debug(p, YELLOW);
                currentTarget = p;
            }
        }
    }

    for (int i = (&allies).length() - 1; i >= 0; i--)
    {
        if (time() >= (&allies).raw()[i].expires)
        {
            (&allies).swapback(i);
        }
        else
        {
            float3 p = (&allies).raw()[i].position;
            debug(p, GREEN);
        }
    }

    byte[MaxCommandDataSize] _command;

    int commandId = dequeue_command(&_command);

    if (commandId == 1)
    {
        CommandAttackAt* command = &_command as CommandAttackAt*;
        currentUserTarget = command.position;
        currentDestination = new float3;
    }
    else if (commandId == 2)
    {
        CommandMoveTo* command = &_command as CommandMoveTo*;
        currentUserTarget = new float3;
        currentDestination = command.position;
    }
    else if (commandId == 3)
    {
        currentUserTarget = new float3;
        currentDestination = new float3;
    }

    if (currentUserTarget.x || currentUserTarget.z)
    {
        currentTarget = currentUserTarget;
        shouldShoot = true;
    }

    if (currentTarget.x != 0f &&
        currentTarget.z != 0f)
    {
        turretLastUseTime = time();
        if (shouldShoot)
        {
            shootat(currentTarget, &targetedPosition);
        }
        else
        {
            targetat(currentTarget, &targetedPosition);
        }
    }
    else if (time() - turretLastUseTime > 5f)
    {
        CombatTurret.target_rotation = 0f;
        CombatTurret.target_angle = 0f;
    }

    if (currentDestination.x != 0f &&
        currentDestination.y != 0f)
    {
        move_to(currentDestination.x, currentDestination.y);
    }
    else
    {
        stop_moving();
    }
}
