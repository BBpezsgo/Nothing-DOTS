using "~/Projects/BBLang/Core/StandardLibrary/Primitives.bbc";
using "~/Projects/BBLang/Core/StandardLibrary/System.bbc";
using "~/Projects/BBLang/Core/StandardLibrary/System.Math.bbc";
using "~/Projects/BBLang/Core/StandardLibrary/System.Vectors.bbc";
using "~/Projects/BBLang/Core/StandardLibrary/System.Console.bbc";
using "~/Projects/BBLang/Core/StandardLibrary/System.Memory.bbc";
using "turret.bbc";
using "move.bbc";
using "api.bbc";

[UnitCommand(1, "Attack at")]
struct CommandAttackAt
{
    [Context("position")] Vector2 position;
}

[UnitCommand(2, "Move to")]
struct CommandMoveTo
{
    [Context("position")] Vector2 position;
}

const int MaxPacketLength = 9 + 1;
const u8 REQUEST_HEADER = 0b_11110000;
const u8 RESPONSE_HEADER = 0b_01111000;

struct VerificationRequestPacket
{
    byte Header;
    Vector2 Position;
}

struct VerificationResponsePacket
{
    byte Header;
    Vector2 Position;
}

const int MaxCommandDataSize = 8;

*Mapped = new MappedMemory;

const f32 PI = 3.14159265359f;
const f32 TAU = PI * 2f;
const u8 true = (u8)1;
const u8 false = (u8)0;
const f32 DistanceThreshold = 2f;
const f32 DistanceThresholdSq = DistanceThreshold * DistanceThreshold;

void Receive()
{
    u8[MaxPacketLength] v;
    f32 direction;

    while (1)
    {
        i32 receivedLength = receive(&v, MaxPacketLength, &direction);
        if (!receivedLength) { break; }

        if (v[0] == (u8)REQUEST_HEADER &&
            receivedLength == sizeof(VerificationRequestPacket))
        {
            VerificationRequestPacket* packet = &v as VerificationRequestPacket*;

            VerificationResponsePacket responsePacket = new VerificationResponsePacket;
            responsePacket.Header = (u8)RESPONSE_HEADER;
            responsePacket.Position = packet.Position;

            if (DistanceSqr(packet.Position, Mapped.Position) < DistanceThresholdSq)
            {
                debug(packet.Position, CYAN);

                send(&responsePacket as u8[]*, sizeof(VerificationResponsePacket), direction, 0.1f);
            }
            else
            {
                for (int i = 0; i < (&allies).Length(); i++)
                {
                    f32 distanceSqr = DistanceSqr((&allies).Raw()[i].Position, packet.Position);
                    if (distanceSqr < DistanceThresholdSq)
                    {
                        send(&responsePacket as u8[]*, sizeof(VerificationResponsePacket), direction, 0.1f);
                        return;
                    }
                }
            }
        }
        else if (v[0] == (u8)RESPONSE_HEADER &&
                 receivedLength == sizeof(VerificationResponsePacket))
        {
            VerificationResponsePacket* packet = &v as VerificationResponsePacket*;

            Vector2 pos = packet.Position;
            ToLocal(&pos);
            Unit unit;
            unit.Position = pos;
            unit.Recorded = time();
            unit.Expires = time() + 10f;
            unit.VerificationSentAt = time();
            RemoveUnitAt(&enemies, unit.Position);
            UpdateUnit(&allies, unit);
        }
    }
}

int UnitIndexAt(List<Unit>* units, Vector2 position)
{
    for (int i = 0; i < units.Length(); i++)
    {
        if (DistanceSqr(units.Raw()[i].Position, position) < DistanceThresholdSq)
        { return i; }
    }
    return -1;
}

void UpdateUnit(List<Unit>* units, Unit unit)
{
    int existing = UnitIndexAt(units, unit.Position);
    if (existing == -1)
    {
        if (units.Length() >= 4)
        {
            units.Raw()[0] = unit;
        }
        else
        {
            units.Add(unit);
        }
    }
    else
    {
        unit.Position.x = (units.Raw()[existing].Position.x + unit.Position.x) * 0.5f;
        unit.Position.y = (units.Raw()[existing].Position.y + unit.Position.y) * 0.5f;
        units[existing] = unit;
    }
}

void RemoveUnitAt(List<Unit>* units, Vector2 unit)
{
    u8 isNotDone = true;
    for (int i = 0; isNotDone && i < units.Length(); i++)
    {
        f32 distanceSqr = DistanceSqr(units.Raw()[i].Position, unit);
        if (distanceSqr < DistanceThresholdSq)
        {
            isNotDone = false;
            units.Remove(i);
        }
    }
}

void Radar()
{
    f32 radarDistance = radar();
    if (radarDistance > 0f &&
        Abs(prevRadarDistance - radarDistance) > .5f)
    {
        prevRadarDistance = radarDistance;

        Vector2 point;
        point.x = Cos(Mapped.RadarDirection);
        point.y = Sin(Mapped.RadarDirection);
        point.x *= radarDistance;
        point.y *= radarDistance;

        Unit enemy;
        enemy.Recorded = time();
        enemy.Expires = time() + 8f;
        enemy.Position = point;
        SendVerificationRequest(&enemy);
        UpdateUnit(&enemies, enemy);
    }
    if (radarDistance == 0f)
    {
        prevRadarDistance = 0f;
    }
    Mapped.RadarDirection = (Mapped.RadarDirection + 0.1f) % TAU;
}

void TrySendVerificationRequest(Unit* unit)
{
    if (unit.VerificationSentAt + 1f < time())
    {
        SendVerificationRequest(unit);
    }
}

void SendVerificationRequest(Unit* unit)
{
    Vector2 point = unit.Position;

    ToGlobal(&point);

    VerificationRequestPacket packet = new VerificationRequestPacket;
    packet.Header = (u8)REQUEST_HEADER;
    packet.Position = point;

    // send(&v, sizeof(VerificationRequestPacket), Mapped.RadarDirection, Asin(1.2f / radarDistance));
    send(&packet as u8[]*, sizeof(VerificationRequestPacket), 0f, 0f);

    debug(point, BLUE);

    unit.VerificationSentAt = time();
}

struct Unit
{
    Vector2 Position;
    f32 Recorded;
    f32 Expires;
    f32 VerificationSentAt;
}

f32 prevRadarDistance = 0f;
Vector2 targetedPosition = new Vector2;
Vector2 currentTarget = new Vector2;
List<Unit> enemies = new List<Unit>(4);
List<Unit> allies = new List<Unit>(4);
Vector2 currentDestination = new Vector2;
u8 shouldShoot = false;
f32 turretLastUseTime = 0f;

while (1)
{
    Receive();

    Radar();

    currentTarget = new Vector2;
    shouldShoot = false;

    for (int i = (&enemies).Length() - 1; i >= 0; i--)
    {
        if (time() >= (&enemies).Raw()[i].Expires)
        {
            (&enemies).Remove(i);
        }
        else
        {
            TrySendVerificationRequest(&(&enemies).Raw()[i]);
            Vector2 p = (&enemies).Raw()[i].Position;
            if (time() >= (&enemies).Raw()[i].Recorded + 4f)
            {
                ldebug(p, RED);
                currentTarget = p;
                shouldShoot = true;
            }
            else if (time() >= (&enemies).Raw()[i].Recorded + 1f)
            {
                ldebug(p, YELLOW);
                currentTarget = p;
            }
            else
            {
                ldebug(p, YELLOW);
            }
        }
    }

    for (int i = (&allies).Length() - 1; i >= 0; i--)
    {
        if (time() >= (&allies).Raw()[i].Expires)
        {
            TrySendVerificationRequest(&(&allies).Raw()[i]);
            (&allies).Remove(i);
        }
        else
        {
            Vector2 p = (&allies).Raw()[i].Position;
            ldebug(p, GREEN);
        }
    }

    byte[MaxCommandDataSize] _command;

    int commandId = dequeue_command(&_command);

    if (commandId == 1)
    {
        CommandAttackAt* command = &_command as CommandAttackAt*;
        currentTarget = command.position;
        currentDestination = new Vector2;
        ToLocal(&currentTarget);
    }
    else if (commandId == 2)
    {
        CommandMoveTo* command = &_command as CommandMoveTo*;
        currentTarget = new Vector2;
        currentDestination = command.position;
    }

    if (currentTarget.x != 0f &&
        currentTarget.y != 0f)
    {
        turretLastUseTime = time();
        if (shouldShoot)
        {
            ShootAt(currentTarget, &targetedPosition);
        }
        else
        {
            TargetAt(currentTarget, &targetedPosition);
        }
    }
    else if (time() - turretLastUseTime > 5f)
    {
        Mapped.TurretTargetRotation = 0f;
        Mapped.TurretTargetAngle = 0f;
    }

    if (currentDestination.x != 0f &&
        currentDestination.y != 0f)
    {
        MoveTo(currentDestination.x, currentDestination.y);
    }
}
