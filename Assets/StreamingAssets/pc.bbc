using "lib/api.bbc";
using "lib/protocol.bbc";

void Receive()
{
    u8[MaxPacketLength] v;
    float3 direction;

    while (1)
    {
        i32 receivedLength = wreceive(&v, MaxPacketLength, &direction);
        if (!receivedLength) { break; }

        if (v[0] == (u8)REQUEST_HEADER &&
            receivedLength == sizeof(VerificationRequestPacket))
        {
            VerificationRequestPacket* packet = &v as VerificationRequestPacket*;

            print("I-REQ ");
            print(packet.position);
            printline();

            if (distancesqr(packet.position, GPS.position) < DistanceThresholdSq)
            {
                print(" M");
                VerificationResponsePacket responsePacket = new VerificationResponsePacket;
                responsePacket.header = (u8)RESPONSE_HEADER;
                responsePacket.position = GPS.position;
                debug(packet.position, CYAN);
                wsend(&responsePacket as u8[]*, sizeof(VerificationResponsePacket), &direction);
            }
            else
            {
                for (int i = 0; i < (&allies).length(); i++)
                {
                    f32 distanceSqr = distancesqr((&allies).raw()[i].position, packet.position);
                    if (distanceSqr < DistanceThresholdSq)
                    {
                        print(" K");
                        IndirectVerificationResponsePacket indirectResponsePacket = new IndirectVerificationResponsePacket;
                        indirectResponsePacket.header = (u8)INDIRECT_RESPONSE_HEADER;
                        indirectResponsePacket.position = (&allies).raw()[i].position;
                        indirectResponsePacket.expires = (&allies).raw()[i].expires;
                        wsend(&indirectResponsePacket as u8[]*, sizeof(IndirectVerificationResponsePacket), &direction);
                        return;
                    }
                }
            }
        }
        else if (v[0] == (u8)RESPONSE_HEADER &&
                 receivedLength == sizeof(VerificationResponsePacket))
        {
            VerificationResponsePacket* packet = &v as VerificationResponsePacket*;

            print("I-RES ");
            print(packet.position);
            printline();

            Unit unit;
            unit.position = packet.position;
            unit.recorded = time();
            unit.expires = time() + 10f;
            unit.verification_sent_at = time();
            unit.position_records = 1;
            remove_unit_at(&enemies, unit.position);
            int j = set_unit(&allies, unit);

            for (int i = 0; i < (&allies).length(); i++)
            {
                if (i != j)
                {
                    direction = (&allies).raw()[i].position;
                    tolocal(&direction);
                    normalise(&direction);

                    printline("NTFY");

                    IndirectVerificationResponsePacket indirectResponsePacket = new IndirectVerificationResponsePacket;
                    indirectResponsePacket.header = INDIRECT_RESPONSE_HEADER;
                    indirectResponsePacket.position = packet.position;
                    indirectResponsePacket.expires = unit.expires;
                    wsend(&indirectResponsePacket as u8[]*, sizeof(IndirectVerificationResponsePacket), &direction);
                }
            }
        }
        else if (v[0] == (u8)ENEMY_HEADER &&
                 receivedLength == sizeof(EnemyNotificationPacket))
        {
            EnemyNotificationPacket* packet = &v as EnemyNotificationPacket*;

            print("I-E ");
            print(packet.position);
            printline();

            Unit unit;
            unit.position = packet.position;
            unit.recorded = 0f;
            unit.expires = time() + 5f;
            unit.verification_sent_at = time();
            unit.position_records = 1;
            set_unit(&enemies, unit);
        }
        else if (v[0] == (u8)INDIRECT_RESPONSE_HEADER &&
                 receivedLength == sizeof(IndirectVerificationResponsePacket))
        {
            IndirectVerificationResponsePacket* packet = &v as IndirectVerificationResponsePacket*;

            print("I-RES ");
            print(packet.position);
            printline();

            Unit unit;
            unit.position = packet.position;
            unit.recorded = time();
            unit.expires = packet.expires;
            unit.verification_sent_at = time();
            unit.position_records = 1;
            remove_unit_at(&enemies, unit.position);
            set_unit(&allies, unit);
        }
        else if (v[0] == (u8)RADAR_POINT &&
                 receivedLength == sizeof(RadarPointPacket))
        {
            RadarPointPacket* packet = &v as RadarPointPacket*;

            if (distancesqr(packet.position, GPS.position) > DistanceThresholdSq)
            {
                print('?');
                print(packet.position);
                printline();

                if (unit_index_at(&allies, packet.position) != -1)
                {
                    print('.');
                    print(packet.position);
                    printline();
                }
                else
                {
                    print('!');
                    print(packet.position);
                    printline();

                    Unit enemy;
                    enemy.recorded = time();
                    enemy.expires = time() + 12f;
                    enemy.position = packet.position;
                    enemy.position_records = 1;
                    //send_verification_request(&enemy);
                    update_unit(&enemies, enemy);
                }
            }
        }
    }

    while (1)
    {
        i32 receivedLength = receive(&v, MaxPacketLength);
        if (!receivedLength) { break; }

        if (v[0] == (u8)REQUEST_HEADER &&
            receivedLength == sizeof(VerificationRequestPacket))
        {
            VerificationRequestPacket* packet = &v as VerificationRequestPacket*;

            print("I-REQ ");
            print(packet.position);
            printline();

            if (distancesqr(packet.position, GPS.position) < DistanceThresholdSq)
            {
                print(" M");
                VerificationResponsePacket responsePacket = new VerificationResponsePacket;
                responsePacket.header = (u8)RESPONSE_HEADER;
                responsePacket.position = GPS.position;
                debug(packet.position, CYAN);
                send(&responsePacket as u8[]*, sizeof(VerificationResponsePacket));
            }
            else
            {
                for (int i = 0; i < (&allies).length(); i++)
                {
                    f32 distanceSqr = distancesqr((&allies).raw()[i].position, packet.position);
                    if (distanceSqr < DistanceThresholdSq)
                    {
                        print(" K");
                        IndirectVerificationResponsePacket indirectResponsePacket = new IndirectVerificationResponsePacket;
                        indirectResponsePacket.header = (u8)INDIRECT_RESPONSE_HEADER;
                        indirectResponsePacket.position = (&allies).raw()[i].position;
                        indirectResponsePacket.expires = (&allies).raw()[i].expires;
                        send(&indirectResponsePacket as u8[]*, sizeof(IndirectVerificationResponsePacket));
                        return;
                    }
                }
            }
        }
        else if (v[0] == (u8)ENEMY_HEADER &&
                 receivedLength == sizeof(EnemyNotificationPacket))
        {
            EnemyNotificationPacket* packet = &v as EnemyNotificationPacket*;

            print("I-E ");
            print(packet.position);
            printline();

            Unit unit;
            unit.position = packet.position;
            unit.recorded = 0f;
            unit.expires = time() + 5f;
            unit.verification_sent_at = time();
            unit.position_records = 1;
            set_unit(&enemies, unit);
        }
        else if (v[0] == (u8)INDIRECT_RESPONSE_HEADER &&
                 receivedLength == sizeof(IndirectVerificationResponsePacket))
        {
            IndirectVerificationResponsePacket* packet = &v as IndirectVerificationResponsePacket*;

            print("I-RES ");
            print(packet.position);
            printline();

            Unit unit;
            unit.position = packet.position;
            unit.recorded = time();
            unit.expires = packet.expires;
            unit.verification_sent_at = time();
            unit.position_records = 1;
            remove_unit_at(&enemies, unit.position);
            set_unit(&allies, unit);
        }
        else if (v[0] == (u8)RADAR_POINT &&
                 receivedLength == sizeof(RadarPointPacket))
        {
            RadarPointPacket* packet = &v as RadarPointPacket*;

            if (distancesqr(packet.position, GPS.position) > DistanceThresholdSq)
            {
                print('?');
                print(packet.position);
                printline();

                if (unit_index_at(&allies, packet.position) != -1)
                {
                    print('.');
                    print(packet.position);
                    printline();
                }
                else
                {
                    print('!');
                    print(packet.position);
                    printline();

                    Unit enemy;
                    enemy.recorded = time();
                    enemy.expires = time() + 12f;
                    enemy.position = packet.position;
                    enemy.position_records = 1;
                    //send_verification_request(&enemy);
                    update_unit(&enemies, enemy);
                }
            }
        }
    }
}

List<Unit> enemies = new List<Unit>(4);
List<Unit> allies = new List<Unit>(4);
int i = 0;
int j = 0;

printline("Started ...");

while (1)
{
    LEDs.custom_led = true;

    Receive();

    if ((&enemies).length())
    {
        i = (i + 1) % (&enemies).length();
        if (time() >= (&enemies).raw()[i].expires)
        {
            (&enemies).swapback(i);
            printline("EXP");
        }
        else
        {
            float3 p = (&enemies).raw()[i].position;
            if (time() >= (&enemies).raw()[i].recorded + 4f)
            {
                if (time() >= (&enemies).raw()[i].notified_at + 5f)
                {
                    EnemyNotificationPacket notificationPacket;
                    notificationPacket.header = ENEMY_HEADER;
                    notificationPacket.position = p;
                    wsend(&notificationPacket as u8[]*, sizeof(EnemyNotificationPacket));
                    (&enemies).raw()[i].notified_at = time();
                }
                debug(p, RED);
            }
            else if (time() >= (&enemies).raw()[i].recorded + 1f)
            {
                debug(p, YELLOW);
            }
            printline("CHK");
            try_send_verification_request(&(&enemies).raw()[i]);
        }
    }

    if ((&allies).length())
    {
        j = (j + 1) % (&allies).length();
        if (time() >= (&allies).raw()[j].expires)
        {
            printline("RTH");
            try_send_verification_request(&(&allies).raw()[j]);
            (&allies).swapback(j);
        }
        else
        {
            debug((&allies).raw()[j].position, GREEN);
        }
    }
}
